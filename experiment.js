const Graph = require('graphology');
const jsdom = require("jsdom");
const gexf = require('graphology-gexf');
const fs = require('fs');
const { createCanvas, loadImage } = require('canvas')
const d3 = require('d3')

// Read file
var gexf_string;
try {
    gexf_string = fs.readFileSync('data/test.gexf', 'utf8');
    console.log('GEXF file loaded');    
} catch(e) {
    console.log('Error:', e.stack);
}

// Parse string
var g = gexf.parse(Graph, gexf_string);
console.log('GEXF parsed');

const cm2inch = 0.393701

// MAKE A MAP
//
//  This script generates a network map as a raster image (in pixels)
//  REQUIRES A JSON generated by Prepare. Paste it in the settings below.


/// EDIT SETTINGS BELOW

var settings = {}

// Auto-download the image once it is done
settings.save_at_the_end = true

// Image size and resolution
settings.dpi = 72 // Dots per inch. Default=72 HighRes=300 PhotoPrint=1440
settings.image_size = 100 // Image width in centimeters
settings.tile_factor = 1 // Integer, default 1. Number of rows and columns of the grid of exported images.
settings.width =  100 * Math.floor(settings.image_size * cm2inch * settings.dpi / settings.tile_factor / 100) // tile size, in pixels
settings.height = 100 * Math.floor(settings.image_size * cm2inch * settings.dpi / settings.tile_factor / 100) // tile size, in pixels

// Reference pen size (determines many line thicknesses)
settings.pen_size = 0.5

// Zoom:
// You can zoon on a given point of the network
// to focus on a specific detail. It's not very easy to use
// because you must find the right point by trial and error.
// By default, a slight unzoom gives a welcome space on the borders
settings.zoom_enabled = true
settings.zoom_window_size = 1.1 // range from 0 to 1 (dezooms if >1)
settings.zoom_point = {x:0.6, y:0.5} // range from 0 to 1

// Layers:
// Decide which layers are drawn.
// The settings for each layer are below.
settings.draw_background = true
settings.draw_network_shape_fill = false
settings.draw_network_shape_contour = false
settings.draw_cluster_fills = false
settings.draw_cluster_contours = false
settings.draw_edges = true
settings.draw_nodes = true
settings.draw_node_labels = true

// Layer: Background
// Original Backscatter palette: "#D9D8DA"
// Lighter for more contrast, a little warm: "#e0dcd9"
settings.background_color = "#e3d6c1"

// Layer: Network shape
//        (a potato for the whole network)
// ...generic structure
settings.network_shape_size = 3 // Range: more than 0, default to 1.
settings.network_shape_swelling = 0.9 // Range: 0.01 to 0.99 // Balanced: 0.5 // Acts on size
settings.network_shape_smoothness = 15 // Range: more than 0 to 10 or more // Makes rounder clusters
// ...shape fill
settings.network_shape_fill_alpha = 0.4 // Opacity // Range from 0 to 1
settings.network_shape_fill_color = "#eee"
// ...shape contour
settings.network_shape_contour_thickness = 1 // Min: 1
settings.network_shape_contour_alpha = 0.8 // Opacity // Range from 0 to 1
settings.network_shape_contour_color = "#bb9178"

// Layer: Clusters
//        (a potato per modality of tqrget attribute)
// ...generic structure
settings.cluster_all_modalities = false // By default, we only use modalities specified in "node_clusters"
settings.cluster_shape_size = 2 // Range: more than 0, default to 1.
settings.cluster_shape_swelling = 0.6 // Range: 0.01 to 0.99 // Balanced: 0.5 // Acts on size
settings.cluster_shape_smoothness = 30// Range: more than 0 to 10 or more // Makes rounder clusters
// ...cluster fills
settings.cluster_fill_alpha = 0.3 // Opacity // Range from 0 to 1
settings.cluster_fill_color_by_modality = true // if false, use default color below
settings.cluster_fill_color_default = "#8B8B8B"
// ...cluster contours
settings.cluster_contour_thickness = settings.pen_size // Range: 0 to 10 or more
settings.cluster_contour_alpha = 1 // Opacity // Range from 0 to 1
settings.cluster_contour_color_by_modality = true // if false, use default color below
settings.cluster_contour_color_default = "#8B8B8B"

// Layer: Edges
settings.edge_alpha = 1 // Opacity // Range from 0 to 1
settings.edge_high_quality = true // Halo around nodes // Time-consuming

// Layer: Nodes
settings.adjust_voronoi_range = 100 // Factor // Larger node halo
settings.node_size = 0.8 // Factor to adjust the nodes drawing size

// Layer: Node labels
settings.label_max_length = 64 // Number of characters before truncate. Infinity is a valid value.
settings.label_font_min_size = 5 // in pt based on set dpi
settings.label_font_max_size = 16  // in pt based on set dpi
settings.label_font_thickness = 1 * settings.pen_size
settings.label_border_thickness = 5 * settings.pen_size

// Main clusters and color code:
// Clusters are defined by the modalities of a given attribute.
// This specifies which is this attribute, and which
// modalities have which colors. You can generate this
// JSON object with the PREPARE script.
settings.node_clusters = {
  "attribute_id": "city",
  "modalities": {
    "København": {
      "label": "København",
      "count": 7249,
      "color": "#ac5b83"
    },
    "Copenhagen": {
      "label": "Copenhagen",
      "count": 6074,
      "color": "#9a6838"
    },
    "Aarhus": {
      "label": "Aarhus",
      "count": 3767,
      "color": "#7c8f12"
    },
    "Odense": {
      "label": "Odense",
      "count": 2553,
      "color": "#b54c5e"
    },
    "Aalborg": {
      "label": "Aalborg",
      "count": 1210,
      "color": "#3d803e"
    },
    "Roskilde": {
      "label": "Roskilde",
      "count": 895,
      "color": "#40588e"
    }
  },
  "default_color": "#5f6f79"}

// Advanced settings
settings.max_precomputations_size = 2500 // Above that size, we approximate the voronoi
settings.label_collision_size = 2500 // Canvas size for label collision detection

/// (END OF SETTINGS)


/// INIT
report("Initialization")

// Fix missing coordinates and/or colors:
//  some parts of the script require default values
//  that are sometimes missing. We add them for consistency.)
addMissingVisualizationData()

// Create the canvas where the image will be rendered
var canvas, ctx

rescaleGraphToGraphicSpace(false)
var precomputedPreTiling = precomputePreTiling()

var xtile, ytile
for (xtile=0; xtile<settings.tile_factor; xtile++) {
	for (ytile=0; ytile<settings.tile_factor; ytile++) {
		
		canvas = createCanvas(settings.width, settings.height)
		ctx = canvas.getContext("2d")

		// Normalize coordinates:
		//  Most networks have arbitrary coordinates. Here we
		//  normalize them to limit side effects. In particular, we
		//  center the graph on its barycenter (center of gravity).
		rescaleGraphToGraphicSpace(true)

		// Build image
		// if (xtile==0 && ytile==1)
			build(precomputedPreTiling)
	}
}

/// PROCESS

function precomputePreTiling() {
	var precomputedPreTiling = {}

	if ( settings.draw_network_shape_fill
    || settings.draw_network_shape_contour
  ) {
    precomputedPreTiling.networkShapeImprint = precomputeNetworkShapeImprint()
  }

  if ( settings.draw_cluster_fills
    || settings.draw_cluster_contours
    || settings.draw_cluster_labels
  ) {
    if (settings.cluster_all_modalities) {
      precomputedPreTiling.modalities = precomputeModalities()
    } else {
      precomputedPreTiling.modalities = d3.keys(settings.node_clusters.modalities)
    }
    precomputedPreTiling.clusterImprints = precomputeClusterImprints(precomputedPreTiling.modalities, settings.node_clusters.attribute_id)
  }

  if (settings.draw_nodes || settings.draw_node_labels) {
    precomputedPreTiling.nodesBySize = precomputeNodesBySize()
  }

  // Draw node labels
  if (settings.draw_node_labels) {
    precomputedPreTiling.visibleLabels = precomputeVisibleLabels(precomputedPreTiling.nodesBySize)
  }

	return precomputedPreTiling
}

function build(precomputedPreTiling) {
  // Precompute stuff:
  //  Depending on the settings, some things must be precomputed
  var modalities, voronoiData, networkShapeImprint, clusterImprints
  if ( settings.draw_edges && settings.edge_high_quality ) {
  	voronoiData = precomputeVoronoi()
  }

  // We draw the image layer by layer.
  // Each layer is drawn separately and merged one after another.
  // The reason for that is to allow drawing temporary
  // things on the canvas.
  var layeredImage = getEmptyLayer(ctx)

  // Draw background
  if (settings.draw_background) {
    layeredImage = drawLayerOnTop(layeredImage,
      drawBackgroundLayer(ctx)
    )
  }

  // Draw network shape fill
  if (settings.draw_network_shape_fill) {
    layeredImage = drawLayerOnTop(layeredImage,
      drawNetworkShapeFillLayer(ctx, precomputedPreTiling.networkShapeImprint)
    )
  }

  // Draw network shape contour
  if (settings.draw_network_shape_contour) {
    layeredImage = drawLayerOnTop(layeredImage,
      drawNetworkShapeContourLayer(ctx, precomputedPreTiling.networkShapeImprint)
    )
  }

  // Draw edges
  if (settings.draw_edges) {
    layeredImage = drawLayerOnTop(layeredImage,
      drawEdgesLayer(ctx, voronoiData)
    )
  }

  // Draw nodes
  if (settings.draw_nodes) {
    layeredImage = drawLayerOnTop(layeredImage,
      drawNodesLayer(ctx, precomputedPreTiling.nodesBySize)
    )
  }

  // Draw cluster contours
  if (settings.draw_cluster_contours) {
    layeredImage = drawLayerOnTop(layeredImage,
      drawClustersContourLayer(ctx, precomputedPreTiling.clusterImprints, precomputedPreTiling.modalities)
    )
  }

  // Draw node labels
  if (settings.draw_node_labels) {
    layeredImage = drawLayerOnTop(layeredImage,
      drawNodeLabelsLayer(ctx, precomputedPreTiling.visibleLabels)
    )
  }

  // Draw cluster fills
  if (settings.draw_cluster_fills && !settings.cluster_fill_above_nodes) {
    layeredImage = overlayClustersFillLayer(ctx, layeredImage, precomputedPreTiling.clusterImprints, precomputedPreTiling.modalities)
  }

  // Finally we compile all the layers
  drawLayers(ctx, [layeredImage])

  // Save if needed
  saveIfNeeded()

  // SAVE PNG
  var fname = 'test'
  if (settings.tile_factor > 1) {
  	fname = fname + ' ' + settings.width + 'x' + settings.height + ' ' + xtile + ',' + ytile
  }
  const out = fs.createWriteStream(__dirname + '/data/'+fname+'.png')
	const stream = canvas.createPNGStream()
	stream.pipe(out)
	out.on('finish', () =>  console.log('The PNG file was created.'))
}





/// FUNCTIONS

function addMissingVisualizationData() {
  log("Add missing visualization data...")
  var colorIssues = 0
  var coordinateIssues = 0
  g.nodes().forEach(function(nid){
    var n = g.getNodeAttributes(nid)
    if (!isNumeric(n.x) || !isNumeric(n.y)) {
      var c = getRandomCoordinates()
      n.x = c[0]
      n.y = c[1]
      coordinateIssues++
    }
    if (!isNumeric(n.size)) {
      n.size = 1
    }
    if (n.color == undefined) {
      n.color = '#665'
      colorIssues++
    }
    if (n.label == undefined) {
      n.label = ''
    }
  })

  if (coordinateIssues > 0) {
    alert('Note: '+coordinateIssues+' nodes had coordinate issues. We carelessly fixed them.')
  }

  function isNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n)
  }
  
  function getRandomCoordinates() {
    var candidates
    var d2 = Infinity
    while (d2 > 1) {
      candidates = [2 * Math.random() - 1, 2 * Math.random() - 1]
      d2 = candidates[0] * candidates[0] + candidates[1] * candidates[1]
    }
    var heuristicRatio = 5 * Math.sqrt(g.order)
    return candidates.map(function(d){return d * heuristicRatio})
  }
  report("...done.")
}

function rescaleGraphToGraphicSpace(acknowledge_tiling) {
  log("Rescale graph to graphic space...")

  // General barycenter resize
  var xbarycenter = 0
  var ybarycenter = 0
  var wtotal = 0
  var dx
  var dy
  var ratio

  g.nodes().forEach(function(nid){
    var n = g.getNodeAttributes(nid)
    // We use node size as weight (default to 1)
    n.size = n.size || 1
    xbarycenter += n.size * n.x
    ybarycenter += n.size * n.y
    wtotal += n.size
  })
  xbarycenter /= wtotal
  ybarycenter /= wtotal

  var dmax = 0 // Maximal distance from barycenter
  g.nodes().forEach(function(nid){
    var n = g.getNodeAttributes(nid)
    var d = Math.sqrt( Math.pow(n.x - xbarycenter, 2) + Math.pow(n.y - ybarycenter, 2) )
    dmax = Math.max(dmax, d)
  })

  ratio = ( Math.min(settings.width, settings.height) ) / (2 * dmax)
  console.log("ratio",ratio)

  // Initial resize
  g.nodes().forEach(function(nid){
    var n = g.getNodeAttributes(nid)
    n.x = settings.width / 2 + (n.x - xbarycenter) * ratio
    n.y = settings.height / 2 + (n.y - ybarycenter) * ratio
    n.size *= ratio
  })

  // Additional zoom resize
  if (settings.zoom_enabled) {
    xbarycenter = settings.zoom_point.x * settings.width// - settings.width / 2
    ybarycenter = settings.zoom_point.y * settings.height// - settings.height / 2
    ratio = 1/settings.zoom_window_size

    g.nodes().forEach(function(nid){
      var n = g.getNodeAttributes(nid)
      n.x = settings.width / 2 + (n.x - xbarycenter) * ratio
      n.y = settings.height / 2 + (n.y - ybarycenter) * ratio
      n.size *= ratio
    })
  }

  // Additional resize for tiling
	if (acknowledge_tiling && settings.tile_factor > 1) {
    g.nodes().forEach(function(nid, i){
      var n = g.getNodeAttributes(nid)
      n.x = settings.tile_factor * n.x - xtile * settings.width 
      n.y = settings.tile_factor * n.y - ytile * settings.height
      n.size *= settings.tile_factor
    })
  }  
  report("...done.")
}

function precomputeNodesBySize() {
  log("Precompute nodes by size...")

  // Order nodes by size to draw with the right priority
  var nodesBySize = g.nodes().slice(0)
  // We sort nodes by 1) size and 2) left to right
  nodesBySize.sort(function(naid, nbid){
    var na = g.getNodeAttributes(naid)
    var nb = g.getNodeAttributes(nbid)
    if ( na.size < nb.size ) {
      return 1
    } else if ( na.size > nb.size ) {
      return -1
    } else if ( na.x < nb.x ) {
      return 1
    } else if ( na.x > nb.x ) {
      return -1
    }
    return 0
  })
  nodesBySize.reverse() // Because we draw from background to foreground

  report("...done.")
  return nodesBySize
}

function precomputeModalities() {
  log("Precompute modalities...")
  var modalitiesIndex = {}
  g.nodes().forEach(function(nid){
    var modality = g.getNodeAttribute(nid, settings.node_clusters.attribute_id)
    modalitiesIndex[modality] = true
  })
  report("...done.")
  return d3.keys(modalitiesIndex)
}

function precomputeVoronoi() {
  log("Precompute Voronoi...")

  var i
  var x
  var y
  var d

  var options = {}
  if (settings.width>settings.max_precomputations_size) {
    options.ratio = settings.max_precomputations_size/settings.width
    options.width = Math.floor(options.ratio*settings.width)
    options.height = Math.floor(options.ratio*settings.height)
  } else {
    options.ratio = 1
    options.width = settings.width
    options.height = settings.height
  }
  options.voronoi_range = settings.adjust_voronoi_range * Math.min(options.width,options.height) * settings.tile_factor / g.order / settings.zoom_window_size
  options.voronoi_use_node_size = false

  // Get an index of nodes where ids are integers
  var nodesIndex = g.nodes().slice(0)
  nodesIndex.unshift(null) // We reserve 0 for "no closest"

  // Save this "voronoi id" as a node attribute
  nodesIndex.forEach(function(nid, vid){
    if (vid > 0) {
      var n = g.getNodeAttributes(nid)
      n.vid = vid
    }
  })

  // Init a pixel map of integers for voronoi ids
  var vidPixelMap
  if (g.order < 255) {
    vidPixelMap = new Uint8Array((options.width+1) * (options.height+1))
  } else if (g.order < 65535) {
    vidPixelMap = new Uint16Array((options.width+1) * (options.height+1))
  } else {
    vidPixelMap = new Uint32Array((options.width+1) * (options.height+1))
  }
  for (i in vidPixelMap) {
    vidPixelMap[i] = 0
  }

  // Init a pixel map of floats for distances
  var dPixelMap = new Uint8Array((options.width+1) * (options.height+1))
  for (i in dPixelMap) {
    dPixelMap[i] = 255
  }

  // Compute the voronoi using the pixel map
  g.nodes().forEach(function(nid){
    var n = g.getNodeAttributes(nid)
    var nsize = options.ratio * n.size * settings.node_size
    var nx = options.ratio * n.x
    var ny = options.ratio * n.y
    var range = nsize + options.voronoi_range
    if (options.voronoi_use_node_size) {
      range *= n.size
    }
    for (x = Math.max(0, Math.floor(nx - range) ); x <= Math.min(options.width, Math.floor(nx + range) ); x++ ){
      for (y = Math.max(0, Math.floor(ny - range) ); y <= Math.min(options.height, Math.floor(ny + range) ); y++ ){
        d = Math.sqrt(Math.pow(nx - x, 2) + Math.pow(ny - y, 2))
 
        if (d < range) {
          var dmod // A tweak of the voronoi: a modified distance in [0,1]
          if (d <= nsize) {
            // "Inside" the node
            dmod = 0
          } else {
            // In the halo range
            dmod = (d - nsize) / options.voronoi_range
          }
          i = x + (options.width+1) * y
          var existingVid = vidPixelMap[i]
          if (existingVid == 0) {
            // 0 means there is no closest node
            vidPixelMap[i] = n.vid
            dPixelMap[i] = Math.floor(dmod*255)
          } else {
            // There is already a closest node. Edit only if we are closer.
            if (dmod*255 < dPixelMap[i]) {
              vidPixelMap[i] = n.vid
              dPixelMap[i] = Math.floor(dmod*255)
            }
          }
        }
      }
    }
  })

  report("...done.")
  return {
    nodesIndex: nodesIndex,
    vidPixelMap: vidPixelMap,
    dPixelMap:dPixelMap,
    width:options.width,
    height:options.height,
    ratio:options.ratio
  }
}

function precomputeNetworkShapeImprint() {
  log("Precompute network shape...")

  var options = {}
  // Steps
  options.step_blur = true
  options.step_save_blurred_canvas = false // For monitoring
  options.step_save_contour = false // For monitoring

  if (settings.width>settings.max_precomputations_size) {
    options.ratio = settings.max_precomputations_size/settings.width
    options.width = Math.floor(options.ratio*settings.width)
    options.height = Math.floor(options.ratio*settings.height)
  } else {
    options.ratio = 1
    options.width = settings.width
    options.height = settings.height
  }
  
  options.node_size_margin = 15 * Math.min(options.width, options.height) / 1000 / settings.zoom_window_size
  options.node_size_factor = settings.network_shape_size // above 0, default 1
  options.blur_radius = settings.network_shape_smoothness * Math.min(options.width, options.height) / 1000 / settings.zoom_window_size
  options.gradient_threshold = 1-settings.network_shape_swelling // Idem on a secondary pass

  // New Canvas
  var newCanvas = createCanvas()
  newCanvas.width = options.width
  newCanvas.height = options.height
  var ctx = newCanvas.getContext("2d")

  g.nodes().forEach(function(nid){
    var n = g.getNodeAttributes(nid)
    var radius = options.node_size_margin + options.node_size_factor * options.ratio * n.size * settings.node_size
    var nx = options.ratio * n.x
    var ny = options.ratio * n.y

    ctx.beginPath()
    ctx.arc(nx, ny, radius, 0, 2 * Math.PI, false)
    ctx.lineWidth = 0
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'
    ctx.shadowColor = 'transparent'
    ctx.fill()
  })

  var imgd = ctx.getImageData(0, 0, options.width, options.height)

  // Blur
  if (options.step_blur) {
    // Blur
    imgd = blur(imgd, options.blur_radius, ctx)

    // Normalize alpha at 80% (80% normalised & 20% original)
    imgd = normalizeAlpha(imgd, 0, 255, 0.8, ctx)

    // data to canvas
  	ctx.putImageData( imgd, 0, 0 )
  }

  // SAVE PNG
  if (options.step_save_blurred_canvas) {
	  var fname = 'network shape monitoring'
	  const out = fs.createWriteStream(__dirname + '/data/'+fname+'.png')
		const stream = newCanvas.createPNGStream()
		stream.pipe(out)
		out.on('finish', () =>  console.log('The PNG file for shape contour monitoring was created.'))
	}

	// Find contour
	var values = imgd.data.filter(function(d,i){ return i%4==3 })
	var contour = d3.contours()
    .size([options.width, options.height])
    .thresholds(d3.range(0, 255))
    .contour(values, Math.round(255*options.gradient_threshold));

  // SAVE PNG
  if (options.step_save_contour) {
  	const path = d3.geoPath(null, ctx)
  	ctx.beginPath()
    path(contour)
    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'
    ctx.fill()

    var fname = 'network shape contour monitoring'
	  const out = fs.createWriteStream(__dirname + '/data/'+fname+'.png')
		const stream = newCanvas.createPNGStream()
		stream.pipe(out)
		out.on('finish', () =>  console.log('The PNG file for shape contour monitoring was created.'))
	}
  
  report("...done.")
	return {ratio:options.ratio, contour:contour}
}

function precomputeClusterImprints(modalities, attId) {
  var options = {}

  if (settings.width>settings.max_precomputations_size) {
    options.ratio = settings.max_precomputations_size/settings.width
    options.width = Math.floor(options.ratio*settings.width)
    options.height = Math.floor(options.ratio*settings.height)
  } else {
    options.ratio = 1
    options.width = settings.width
    options.height = settings.height
  }
  
  options.node_size_margin = 5 * Math.min(options.width, options.height) / 1000 / settings.zoom_window_size
  options.node_size_factor = settings.cluster_shape_size // above 0, default 1
  options.blur_radius = settings.cluster_shape_smoothness * Math.min(options.width, options.height) / 1000 / settings.zoom_window_size
  options.gradient_threshold = 1-settings.cluster_shape_swelling // Idem on a secondary pass

  var imprintsByModality = {}
  modalities.forEach(function(modality, i){
    log("Precompute cluster shape for "+modality+"...")

    // New Canvas
	  var newCanvas = createCanvas()
	  newCanvas.width = options.width
	  newCanvas.height = options.height
	  var ctx = newCanvas.getContext("2d")

	  g.nodes()
	  	.filter(function(nid){
	  		return g.getNodeAttribute(nid, attId) == modality
	  	})
	  	.forEach(function(nid){
		    var n = g.getNodeAttributes(nid)
		    var radius = options.node_size_margin + options.node_size_factor * options.ratio * n.size * settings.node_size
		    var nx = options.ratio * n.x
		    var ny = options.ratio * n.y

		    ctx.beginPath()
		    ctx.arc(nx, ny, radius, 0, 2 * Math.PI, false)
		    ctx.lineWidth = 0
		    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'
		    ctx.shadowColor = 'transparent'
		    ctx.fill()
		  })

	  var imgd = ctx.getImageData(0, 0, options.width, options.height)

    // Blur
    imgd = blur(imgd, options.blur_radius, ctx)
    // Normalize alpha at 80% (80% normalised & 20% original)
    imgd = normalizeAlpha(imgd, 0, 255, 0.8, ctx)

		// Find contour
		var values = imgd.data.filter(function(d,i){ return i%4==3 })
		var contour = d3.contours()
	    .size([options.width, options.height])
	    .thresholds(d3.range(0, 255))
	    .contour(values, Math.round(255*options.gradient_threshold));

    report("...done.")
    imprintsByModality[modality] = {ratio:options.ratio, contour:contour}
  })
  return imprintsByModality
}

function getEmptyLayer(ctx) {
  // Clear canvas
  ctx.clearRect(0, 0, settings.width, settings.height)
  return ctx.getImageData(0, 0, settings.width, settings.height)
}

function drawBackgroundLayer(ctx) {
  log("Draw background layer...")
  // Clear canvas
  ctx.clearRect(0, 0, settings.width, settings.height);
  paintAll(ctx, settings.width, settings.height, settings.background_color)
  report("...done.")
  return ctx.getImageData(0, 0, settings.width, settings.height)
}

function processRescaledImprint(imgd) {
  var options = {}
  options.threshold = 0.5
  options.blur_radius = 0.01 * Math.min(settings.width, settings.height) / settings.zoom_window_size
  // Blur
  imgd = blur(imgd, options.blur_radius)
  // Threshold
  imgd = alphacontrast(imgd, 0, options.threshold, Infinity)
  return imgd
}

function drawNetworkShapeFillLayer(ctx, networkShapeImprint) {
  log("Draw network shape (fill)...")
  // Clear canvas
  ctx.clearRect(0, 0, settings.width, settings.height);
  
  var color = d3.color(settings.network_shape_fill_color)
  color.opacity = settings.network_shape_fill_alpha

	const path = d3.geoPath(null, ctx)
	ctx.translate(-xtile*settings.width, -ytile*settings.height)
	ctx.scale(settings.tile_factor/networkShapeImprint.ratio, settings.tile_factor/networkShapeImprint.ratio)
	ctx.beginPath()
  path(networkShapeImprint.contour)
  ctx.fillStyle = color.toString()
  ctx.fill()

	// Reset current transformation matrix to the identity matrix
	ctx.setTransform(1, 0, 0, 1, 0, 0);

  report("...done.")
  return ctx.getImageData(0, 0, settings.width, settings.height)
}

function drawNetworkShapeContourLayer(ctx, networkShapeImprint) {
	log("Draw network shape (contour)...")
  // Clear canvas
  ctx.clearRect(0, 0, settings.width, settings.height);
  
  var color = d3.color(settings.network_shape_contour_color)
  color.opacity = settings.network_shape_contour_alpha

	const path = d3.geoPath(null, ctx)
	ctx.translate(-xtile*settings.width, -ytile*settings.height)
	ctx.scale(settings.tile_factor/networkShapeImprint.ratio, settings.tile_factor/networkShapeImprint.ratio)
	ctx.beginPath()
  path(networkShapeImprint.contour)
  ctx.lineWidth = settings.network_shape_contour_thickness
  ctx.fillStyle = 'rgba(0, 0, 0, 0)'
  ctx.strokeStyle = color.toString()
  
  ctx.stroke()

	// Reset current transformation matrix to the identity matrix
	ctx.setTransform(1, 0, 0, 1, 0, 0);

  report("...done.")
  return ctx.getImageData(0, 0, settings.width, settings.height)
}

function overlayClustersFillLayer(ctx, backgroundImg, clusterImprints, modalities) {
  modalities
  .forEach(function(modality, i){
    log("Draw cluster fill for "+modality+"...")

	  var color
    if (settings.cluster_fill_color_by_modality) {
      color = settings.node_clusters.default_color || settings.cluster_fill_color_default || "#444"
      if (settings.node_clusters.modalities[modality]) {
        color = settings.node_clusters.modalities[modality].color
      }
    } else {
      color = settings.cluster_fill_color_default
    }
    color = d3.color(color)
	  color.opacity = settings.cluster_fill_alpha

	  // Paint bottom layer
    ctx.putImageData(backgroundImg, 0, 0)

    ctx.globalCompositeOperation = "hard-light"

    var clusterImprint = clusterImprints[modality]
		const path = d3.geoPath(null, ctx)
		ctx.translate(-xtile*settings.width, -ytile*settings.height)
		ctx.scale(settings.tile_factor/clusterImprint.ratio, settings.tile_factor/clusterImprint.ratio)
		ctx.beginPath()
	  path(clusterImprint.contour)
	  ctx.fillStyle = color.toString()
	  ctx.fill()

		// Reset current transformation matrix to the identity matrix
		ctx.setTransform(1, 0, 0, 1, 0, 0);

    ctx.globalCompositeOperation = "source-over"

    backgroundImg = ctx.getImageData(0, 0, backgroundImg.width, backgroundImg.height)

	  report("...done.")
  })
  return backgroundImg
}

function drawClustersContourLayer(ctx, clusterImprints, modalities) {
  return mergeLayers(modalities.map(function(modality, i){

  	log("Draw cluster contour for "+modality+"...")

	  var color
    if (settings.cluster_contour_color_by_modality) {
      color = settings.node_clusters.default_color || settings.cluster_contour_color_default || "#444"
      if (settings.node_clusters.modalities[modality]) {
        color = settings.node_clusters.modalities[modality].color
      }
    } else {
      color = settings.cluster_contour_color_default
    }
    color = d3.color(color)
	  color.opacity = settings.cluster_contour_alpha

	  // Clear canvas
    ctx.clearRect(0, 0, settings.width, settings.height);

    var clusterImprint = clusterImprints[modality]
		const path = d3.geoPath(null, ctx)
		ctx.translate(-xtile*settings.width, -ytile*settings.height)
		ctx.scale(settings.tile_factor/clusterImprint.ratio, settings.tile_factor/clusterImprint.ratio)
		ctx.beginPath()
	  path(clusterImprint.contour)
	  ctx.lineWidth = settings.network_shape_contour_thickness
	  ctx.fillStyle = 'rgba(0, 0, 0, 0)'
	  ctx.strokeStyle = color.toString()
	  
	  ctx.stroke()

		// Reset current transformation matrix to the identity matrix
		ctx.setTransform(1, 0, 0, 1, 0, 0);

	  report("...done.")
    return ctx.getImageData(0, 0, settings.width, settings.height)
  }))
}

function drawEdgesLayer(ctx, voronoiData) {
  log("Draw edges...")
  var options = {}
  options.display_voronoi = false // for monitoring purpose
  options.display_edges = true // disable for monitoring purpose
  options.max_edge_count = Infinity // for monitoring only
  options.edge_thickness = settings.pen_size*Math.min(settings.width, settings.height) / 1000
  options.edge_alpha = settings.edge_alpha
  options.edge_color = "#275473"
  options.node_halo = settings.edge_high_quality
  options.jitter = 0.8

  var gradient = function(d){
    return Math.round(10000*
    	(0.5 + 0.5 * Math.cos(Math.PI - Math.pow(d, 2) * Math.PI))
  	)/10000
  }

  var dPixelMap_u, vidPixelMap_u // unpacked versions
  if (options.display_voronoi || options.node_halo) {
    // Unpack voronoi
    var ratio = Math.max(1, settings.width/settings.max_precomputations_size)

    if (g.order < 255) {
      vidPixelMap_u = new Uint8Array(settings.width * settings.height)
    } else if (g.order < 65535) {
      vidPixelMap_u = new Uint16Array(settings.width * settings.height)
    } else {
      vidPixelMap_u = new Uint32Array(settings.width * settings.height)
    }
    dPixelMap_u = new Uint8Array(settings.width * settings.height)

    var xu, yu, xp, xp1, xp2, dx, yp, yp1, yp2, dy, ip_top_left, ip_top_right, ip_bottom_left, ip_bottom_right
    for (var i=0; i<vidPixelMap_u.length; i++) {
      // unpacked coordinates
      xu = i%settings.width
      yu = (i-xu)/settings.width
      // packed coordinates
      xp = xu/ratio
      xp1 = Math.max(0, Math.min(voronoiData.width, Math.floor(xp)))
      xp2 = Math.max(0, Math.min(voronoiData.width, Math.ceil(xp)))
      dx = (xp-xp1)/(xp2-xp1) || 0
      yp = yu/ratio
      yp1 = Math.max(0, Math.min(voronoiData.height, Math.floor(yp)))
      yp2 = Math.max(0, Math.min(voronoiData.height, Math.ceil(yp)))
      dy = (yp-yp1)/(yp2-yp1) || 0
      // coordinates of the 4 pixels necessary to rescale
      ip_top_left = xp1 + (voronoiData.width+1) * yp1
      ip_top_right = xp2 + (voronoiData.width+1) * yp1
      ip_bottom_left = xp1 + (voronoiData.width+1) * yp2
      ip_bottom_right = xp2 + (voronoiData.width+1) * yp2
      // Rescaling (gradual blending between the 4 pixels)
      dPixelMap_u[i] =
          (1-dx) * (
            (1-dy) * voronoiData.dPixelMap[ip_top_left]
            +  dy  * voronoiData.dPixelMap[ip_bottom_left]
          )
        + dx * (
            (1-dy) * voronoiData.dPixelMap[ip_top_right]
            +  dy  * voronoiData.dPixelMap[ip_bottom_right]
          )
      // For vid we use only one (it's not a number but an id)
      if (dx<0.5) {
        if (dy<0.5) {
          vidPixelMap_u[i] = voronoiData.vidPixelMap[ip_top_left]
        } else {
          vidPixelMap_u[i] = voronoiData.vidPixelMap[ip_bottom_left]
        }
      } else {
        if (dy<0.5) {
          vidPixelMap_u[i] = voronoiData.vidPixelMap[ip_top_right]
        } else {
          vidPixelMap_u[i] = voronoiData.vidPixelMap[ip_bottom_right]
        }
      }
    }

  }

  // Clear canvas
  ctx.clearRect(0, 0, settings.width, settings.height)

  if (options.display_voronoi) {
    console.log("...Draw voronoi (for monitoring)...")
    var size = 1 // <- edit me (tradeoff memory / quality)
    for (x=0; x<settings.width; x+=size) {
      for (y=0; y<settings.height; y+=size) {
        var pixi = Math.floor(x) + settings.width * Math.floor(y)
        var d = dPixelMap_u[pixi]/255
        var c = d3.color("#000")
        if (d < Infinity) {
        	c.opacity = gradient(d)
        }
        ctx.fillStyle = c.toString()
        ctx.fillRect(x, y, size, size)
      }
    }
  }

  // Draw each edge
  if (options.display_edges) {
    ctx.lineCap="round"
    ctx.lineJoin="round"
    ctx.fillStyle = 'rgba(0, 0, 0, 0)';
    g.edges()
      .filter(function(eid, i_){ return i_ < options.max_edge_count })
      .forEach(function(eid, i_){
	      if ((i_+1)%10000 == 0) {
	        console.log("..."+(i_+1)/1000+"K edges drawn...")
	      }
	      var ns = g.getNodeAttributes(g.source(eid))
	      var nt = g.getNodeAttributes(g.target(eid))
	      var color = d3.color(options.edge_color)
	      var path, i, x, y, o, dpixi, lastdpixi, lasto, pixi, pi=0

	      if (options.node_halo) {
	        var d = Math.sqrt(Math.pow(ns.x - nt.x, 2) + Math.pow(ns.y - nt.y, 2))

	        // Build path
	        var iPixStep = 2.5 //Math.max(1.5, 0.7*options.edge_thickness)
	        var l = Math.ceil(d/iPixStep)
	        path = new Int32Array(3*l)
	        for (i=0; i<1; i+=iPixStep/d) {
	          x = (1-i)*ns.x + i*nt.x
	          y = (1-i)*ns.y + i*nt.y

	          // Opacity
	          pixi = Math.floor(x) + settings.width * Math.floor(y)
	          dpixi = dPixelMap_u[pixi]
	          if (dpixi === undefined) {
	          	if (lastdpixi !== undefined) {
	          		o = lasto
	          	} else {
		          	o = 0
	          	}
	          } else {
		          if (vidPixelMap_u[pixi] == ns.vid || vidPixelMap_u[pixi] == nt.vid) {
		            o = 1
		          } else {
		            o = gradient(dpixi/255)
		          }
	          	if (lastdpixi === undefined && pi>3) {
	          		path[(pi-3)+2] = Math.round(o*255)
	          	} 
	          }
	          lastdpixi = dpixi
	          lasto = o

	          path[pi  ] = x
	          path[pi+1] = y
	          path[pi+2] = Math.round(o*255)
	          pi +=3
	          lasto = o
	        }
	        path[3*(l-1)  ] = nt.x
	        path[3*(l-1)+1] = nt.y
	        path[3*(l-1)+2] = 255

	        // Smoothe path
	        if (path.length > 5) {
	          for (i=2; i<path.length-2; i++) {
	            path[i*3+2] = 0.15 * path[(i-2)*3+2] + 0.25 * path[(i-1)*3+2] + 0.2 * path[i*3+2] + 0.25 * path[(i+1)*3+2] + 0.15 * path[(i+2)*3+2]
	          }
	        }
	      } else {
	        path = new Int16Array(6)
	        path[0] = ns.x
	        path[1] = ns.y
	        path[2] = 255
	        path[3] = nt.x
	        path[4] = nt.y
	        path[5] = 255
	      }
	      
	      // Draw path
	      var x, y, o, lastx, lasty, lasto
	      for (i=0; i<path.length; i+=3) {
	        x = Math.floor( 1000 * (path[i] + options.jitter * (0.5 - Math.random())) ) / 1000
	        y = Math.floor( 1000 * (path[i+1] + options.jitter * (0.5 - Math.random())) ) / 1000
	        o = path[i+2]/255
	        
	        // Collapse opacity
	        o = (Math.random()<=o) ? (1) : (0)

	        // Recaliber for lighter line
	        // o *= 0.3 + 0.2*Math.random()

	        if (lastx) {
	          ctx.lineWidth = options.edge_thickness * (0.9 + 0.2*Math.random())
	          color.opacity = (lasto+o)/2
	          ctx.beginPath()
	          ctx.strokeStyle = color.toString()
	        	ctx.moveTo(lastx, lasty)
	        	ctx.lineTo(x, y)
	        	ctx.stroke()
	          ctx.closePath()
	        }

	        lastx = x
	        lasty = y
	        lasto = o
	      }
	    })
  }

  report("...done.")
  return multiplyAlpha(
    ctx.getImageData(0, 0, settings.width, settings.height),
    options.edge_alpha
  )
}

function drawNodesLayer(ctx, nodesBySize) {
  log("Draw nodes...")

  var options = {}
  options.node_stroke = true
  options.node_stroke_width = settings.pen_size * Math.min(settings.width, settings.height)/1000

  // Clear canvas
  ctx.clearRect(0, 0, settings.width, settings.height)

  nodesBySize.forEach(function(nid){
    var n = g.getNodeAttributes(nid)

    var modality = settings.node_clusters.modalities[n[settings.node_clusters.attribute_id]]
    var color = "#e3d6c1"
    /*if (modality) {
      color = modality.color
    } else {
      color = settings.node_clusters.default_color || "#8B8B8B"
    }*/

    var radius = Math.max(settings.node_size * n.size, options.node_stroke_width)

    ctx.lineCap="round"
    ctx.lineJoin="round"

    if (options.node_stroke) {
      ctx.beginPath()
      ctx.arc(n.x, n.y, radius + 0.5*options.node_stroke_width, 0, 2 * Math.PI, false)
      ctx.lineWidth = 0
      ctx.fillStyle = "#275473"
      ctx.shadowColor = 'transparent'
      ctx.fill()
    }

    ctx.beginPath()
    ctx.arc(n.x, n.y, radius - 0.5*options.node_stroke_width, 0, 2 * Math.PI, false)
    ctx.lineWidth = 0
    ctx.fillStyle = color.toString()
    ctx.shadowColor = 'transparent'
    ctx.fill()

    // Draw strokes
    var spacingFactor = 2.5
    for (var ref=spacingFactor*options.node_stroke_width-radius; ref < radius; ref += spacingFactor*options.node_stroke_width) {
      var xref = n.x + ref/Math.sqrt(2)
      var yref = n.y + ref/Math.sqrt(2)
      var r = ref/radius
      var b = Math.sqrt(2) * r
      var theta = Math.asin(-r) + Math.PI/4
      var a = Math.cos(theta) - b
      var x0 = n.x + radius * (-a - b)
      var y0 = n.y + radius * a
      var x1 = n.x + radius * a
      var y1 = n.y + radius * (-b - a)

      ctx.lineWidth = options.node_stroke_width
      ctx.beginPath()
      ctx.strokeStyle = "#275473"
      ctx.moveTo(x0, y0)
      ctx.lineTo(x1, y1)
      ctx.stroke()
      ctx.closePath()

    }

  })

  report("...done.")
  return ctx.getImageData(0, 0, settings.width, settings.height)
}

function getNodeLabelSharedOptions(){
	var options = {}
  options.label_count = Infinity
  options.colored_labels = true
  options.sized_labels = true
  options.true_size = false // false: size adjusted to the right thickness (weight)
  options.label_spacing_factor = 3 // 1=normal; 2=box twice as wide/high etc.
  options.label_spacing_offset = 2 * Math.min(settings.width, settings.height)/1000
  options.font_family = 'Raleway'
  options.font_min_size = settings.label_font_min_size * settings.dpi / 72
  options.font_max_size = settings.label_font_max_size * settings.dpi / 72
  options.font_thickness_optical_correction = 0.9
  options.text_thickness = settings.label_font_thickness * Math.min(settings.width, settings.height)/1000
  options.border_thickness = settings.label_border_thickness * Math.min(settings.width, settings.height)/1000
  options.border_color = settings.background_color
  
  // Note: here we put the scale in options because it is shared
	// Deal with font weights
  //  Relative thicknesses for: Raleway
  var weights =     [ 100, 200, 300, 400, 500, 600, 700, 800, 900 ]
  var thicknesses = [   2, 3.5,   5,   7, 9.5,  12,  15,  18,  21 ]
  var thicknessRatio = 120
  var thicknessToWeight = d3.scaleLinear()
    .domain(thicknesses)
    .range(weights)

  // We restrain the size to the proper steps of the scale
  options.normalizeFontSize = function(size) {
  	// The target thickness is the pen size, which is fixed: options.text_thickness
  	// But to compute the weight, we must know the thickness for a standard size: 1
  	var thicknessForFontSize1 = thicknessRatio * options.text_thickness / size
  	var targetWeight = thicknessToWeight(thicknessForFontSize1)
  	// console.log(size, thicknessForFontSize1, targetWeight)

  	// We need to round to actual weights
    var actualWeight = Math.max(weights[0], Math.min(weights[weights.length-1], 100*Math.round(targetWeight/100)))

    // We can also restrain the size to the actual weight
    var restrainedSize = thicknessRatio * options.text_thickness / thicknessToWeight.invert(actualWeight)

    return [restrainedSize, actualWeight]
  }

  return options
}

function precomputeVisibleLabels(nodesBySize_) {
	log("Precompute visible node labels...")
  var options = getNodeLabelSharedOptions()
  options.download_image = true // For monitoring the process
  options.ratio = settings.label_collision_size/settings.width
  options.width = Math.floor(options.ratio*settings.width)
  options.height = Math.floor(options.ratio*settings.height)
  options.pixmap_size = 1// + Math.floor(0.3 * options.font_min_size)

  var i, x, y, visibleLabels = []

	var canvas = createCanvas(options.width, options.height)
	var ctx = canvas.getContext("2d")
	paintAll(ctx, options.width, options.height, '#FFF') // Useful for monitoring

  // Reverse nodes by size order
  var nodesBySize = nodesBySize_.slice(0)
  nodesBySize.reverse()

  // Init a pixel map of int for bounding boxes
  var pixmapWidth = Math.ceil(options.width/options.pixmap_size)
  var pixmapHeight = Math.ceil(options.height/options.pixmap_size)
  var bbPixmap = new Uint8Array(pixmapWidth * pixmapHeight)
  for (i in bbPixmap) {
    bbPixmap[i] = 0 // 1 means "occupied"
  }

  // Compute scale for labels
  var label_nodeSizeExtent = d3.extent(
    nodesBySize.map(function(nid){
      return options.ratio * g.getNodeAttribute(nid, "size")
    })
  )
  if (label_nodeSizeExtent[0] == label_nodeSizeExtent[1]) {label_nodeSizeExtent[0] *= 0.9}

  // Evaluate labels
  var labelDrawCount = options.label_count
  nodesBySize.forEach(function(nid){
    if(labelDrawCount > 0){

      var n = g.getNodeAttributes(nid)
      var nx = options.ratio * n.x
      var ny = options.ratio * n.y

      var modality = settings.node_clusters.modalities[n[settings.node_clusters.attribute_id]]
      var ncol
      if (modality) {
        ncol = d3.color(modality.color)
      } else {
        ncol = d3.color(settings.node_clusters.default_color || "#8B8B8B")
      }

      var radius = Math.max(settings.node_size * options.ratio * n.size, 2)

      // Precompute the label
      // var color = options.colored_labels ? tuneColorForLabel(ncol) : d3.color('#666')
      var color = d3.color("#363835")
      var fontSize = options.sized_labels
        ? Math.floor(options.font_min_size + (options.ratio * n.size - label_nodeSizeExtent[0]) * (options.font_max_size - options.font_min_size) / (label_nodeSizeExtent[1] - label_nodeSizeExtent[0]))
        : Math.floor(0.6 * options.font_min_size + 0.4 * options.font_max_size)

      var sw = options.normalizeFontSize(fontSize)
      if (!options.true_size) {
        fontSize = sw[0]
      }
      var fontWeight = sw[1]
      ctx.font = buildContextFontString(fontWeight, fontSize, options.font_family)

      // Then, draw the label only if wanted
      var labelCoordinates = {
        x: nx + 0.6 * options.border_thickness + 1.05 * radius,
        y: ny + 0.25 * fontSize
      }

      var label = truncateWithEllipsis(n.label.replace(/^https*:\/\/(www\.)*/gi, ''), settings.label_max_length)

      // Bounding box
      var bbox = getBBox(ctx, fontSize, labelCoordinates, label, options.label_spacing_factor, options.label_spacing_offset)

      // Test bounding box collision
      var collision = false
      var bboxResizedX = Math.floor(bbox.x/options.pixmap_size)
      var bboxResizedY = Math.floor(bbox.y/options.pixmap_size)
      var bboxResizedX2 = Math.ceil((bbox.x + bbox.width)/options.pixmap_size)
      var bboxResizedY2 = Math.ceil((bbox.y + bbox.height)/options.pixmap_size)
      for (x = bboxResizedX; x<bboxResizedX2; x++) {
        for (y = bboxResizedY; y<bboxResizedY2; y++) {
          if (bbPixmap[x + (y*pixmapWidth)] == 1) {
            collision = true
            break
            break
          }
        }
      }
      if (!collision) {

        // Update bounding box data
        for (x = bboxResizedX; x<bboxResizedX2; x++) {
          for (y = bboxResizedY; y<bboxResizedY2; y++) {
            bbPixmap[x + (y*pixmapWidth)] = 1
          }
        }

        // Update count
        labelDrawCount--

        // Add to draw pipe
        visibleLabels.push(nid)

        if (options.download_image) {
        	// Draw bounding box
        	ctx.fillStyle = 'rgba(0, 0, 0, .2)'
        	ctx.fillRect(bboxResizedX, bboxResizedY, bboxResizedX2-bboxResizedX, bboxResizedY2-bboxResizedY)
        	// Draw label
		      ctx.lineWidth = 0
		      ctx.fillStyle = '#000'
		      ctx.fillText(
		        label
		      , labelCoordinates.x
		      , labelCoordinates.y
		      )
        }
      }
    }
  })

  if (options.download_image) {
  	var imgd = ctx.getImageData(0, 0, options.width, options.height)
  	downloadImageData(imgd, 'Monitoring labels')
  }
  

  report("...done.")
  return visibleLabels
}

function drawNodeLabelsLayer(ctx, visibleLabels) {
  log("Draw node labels...")
  var options = getNodeLabelSharedOptions()
  options.draw_labels = true

  var i, x, y

  // Clear canvas
  ctx.clearRect(0, 0, settings.width, settings.height)

  // A thin invisible layer of border color for alpha processing
  var bc = d3.color(options.border_color)
  bc.opacity = 0.1
  paintAll(ctx, settings.width, settings.height, bc.toString())

  // Draw each label
  if (options.draw_labels) {

    // Init a pixel map of int for bounding boxes
    var pixmapWidth = Math.ceil(settings.width/options.pixmap_size)
    var pixmapHeight = Math.ceil(settings.height/options.pixmap_size)
    var bbPixmap = new Uint8Array(pixmapWidth * pixmapHeight)
    for (i in bbPixmap) {
      bbPixmap[i] = 0 // 1 means "occupied"
    }

    // Compute scale for labels
    var label_nodeSizeExtent = d3.extent(
      g.nodes().map(function(nid){
        return g.getNodeAttribute(nid, "size")
      })
    )
    if (label_nodeSizeExtent[0] == label_nodeSizeExtent[1]) {label_nodeSizeExtent[0] *= 0.9}

    // Draw labels
    var labelsStack = []
    visibleLabels.forEach(function(nid){

      var n = g.getNodeAttributes(nid)
      var nx = n.x
      var ny = n.y

      var modality = settings.node_clusters.modalities[n[settings.node_clusters.attribute_id]]
      var ncol
      if (modality) {
        ncol = d3.color(modality.color)
      } else {
        ncol = d3.color(settings.node_clusters.default_color || "#8B8B8B")
      }

      var radius = Math.max(settings.node_size * n.size, 2)

      // Precompute the label
      // var color = options.colored_labels ? tuneColorForLabel(ncol) : d3.color('#666')
      var color = d3.color("#363835")
      var fontSize = options.sized_labels
        ? Math.floor(options.font_min_size + (n.size - label_nodeSizeExtent[0]) * (options.font_max_size - options.font_min_size) / (label_nodeSizeExtent[1] - label_nodeSizeExtent[0]))
        : Math.floor(0.6 * options.font_min_size + 0.4 * options.font_max_size)

      var sw = options.normalizeFontSize(fontSize)
      if (!options.true_size) {
        fontSize = sw[0]
      }
      var fontWeight = sw[1]
      ctx.font = buildContextFontString(fontWeight, fontSize, options.font_family)

      // Then, draw the label only if wanted
      var labelCoordinates = {
        x: nx + 0.6 * options.border_thickness + 1.05 * radius,
        y: ny + 0.25 * fontSize
      }

      var label = truncateWithEllipsis(n.label.replace(/^https*:\/\/(www\.)*/gi, ''), settings.label_max_length)


      // Add to draw pipe
      var l = {
        label: label,
        x: labelCoordinates.x,
        y: labelCoordinates.y,
        font: ctx.font,
        color: color
      }
      labelsStack.push(l)
    })

    // Draw borders
    labelsStack.forEach(function(l){
      ctx.font = l.font
      ctx.lineWidth = options.border_thickness
      ctx.fillStyle = options.border_color
      ctx.strokeStyle = options.border_color

      ctx.fillText(
        l.label
      , l.x
      , l.y
      )
      ctx.strokeText(
        l.label
      , l.x
      , l.y
      )
    })

    // Draw text
    labelsStack.forEach(function(l){
      ctx.font = l.font
      ctx.lineWidth = options.border_thickness
      ctx.fillStyle = options.border_color
      ctx.strokeStyle = options.border_color

      ctx.lineWidth = 0
      ctx.fillStyle = l.color.toString()
      ctx.fillText(
        l.label
      , l.x
      , l.y
      )
    })
  }
  report("...done.")
  return ctx.getImageData(0, 0, settings.width, settings.height)
}

function saveIfNeeded() {
}

function drawLayers(ctx, layers) {
  var imgd = mergeLayers(layers)
  ctx.putImageData( imgd, 0, 0 )
}

function drawLayerOnTop(bottomLayer, topLayer) {

  // New Canvas
  var newCanvas = createCanvas()
  newCanvas.width = bottomLayer.width
  newCanvas.height = bottomLayer.height
  var ctx = newCanvas.getContext("2d")

  // Paint bottom layer
  ctx.putImageData(bottomLayer, 0, 0)

  // Create temporary canvas for top layer
  var canvas2=createCanvas()
  canvas2.width=topLayer.width
  canvas2.height=topLayer.height
  var ctx2=canvas2.getContext("2d")
  ctx2.putImageData(topLayer, 0, 0)

  ctx.drawImage(canvas2,0,0);

  return ctx.getImageData(0, 0, bottomLayer.width, bottomLayer.height)
}

function mergeLayers(layers) {
  var imgd_bottom = layers.shift()
  var imgd_top
  while (imgd_top = layers.shift()) {
    imgd_bottom = drawLayerOnTop(imgd_bottom, imgd_top)
  }

  return imgd_bottom
}

function paintAll(ctx, w, h, color) {
  ctx.beginPath()
  ctx.rect(0, 0, w, h)
  ctx.fillStyle = color
  ctx.fill()
  ctx.closePath()
}

// Code from https://www.html5rocks.com/en/tutorials/canvas/imagefilters/
function convolute(pixels, weights, opaque) {
  var side = Math.round(Math.sqrt(weights.length));
  var halfSide = Math.floor(side/2);
  var src = pixels.data;
  var sw = pixels.width;
  var sh = pixels.height;
  // pad output by the convolution matrix
  var w = sw;
  var h = sh;
  var output = ctx.createImageData(w,h)
  var dst = output.data;
  // go through the destination image pixels
  var alphaFac = opaque ? 1 : 0;
  for (var y=0; y<h; y++) {
    for (var x=0; x<w; x++) {
      var sy = y;
      var sx = x;
      var dstOff = (y*w+x)*4;
      // calculate the weighed sum of the source image pixels that
      // fall under the convolution matrix
      var r=0, g=0, b=0, a=0;
      for (var cy=0; cy<side; cy++) {
        for (var cx=0; cx<side; cx++) {
          var scy = sy + cy - halfSide;
          var scx = sx + cx - halfSide;
          if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
            var srcOff = (scy*sw+scx)*4;
            var wt = weights[cy*side+cx];
            r += src[srcOff] * wt;
            g += src[srcOff+1] * wt;
            b += src[srcOff+2] * wt;
            a += src[srcOff+3] * wt;
          }
        }
      }
      dst[dstOff] = r;
      dst[dstOff+1] = g;
      dst[dstOff+2] = b;
      dst[dstOff+3] = a + alphaFac*(255-a);
    }
  }
  return output;
}

function findCentroid(imgd, modality) {
  var options = {}
  options.monitoring = false // Download intermediate steps

  var total = 0
  var safeguard = 100
  var w = Math.min(settings.width, settings.max_precomputations_size)
  var lasti, i, pixlen

  // Clone image data
  var newCanvas = createCanvas()
  newCanvas.width = imgd.width
  newCanvas.height = imgd.height
  var ctx = newCanvas.getContext("2d")
  var imgd2 = ctx.createImageData(imgd.width, imgd.height);
  imgd2.data.set(imgd.data)

  var pix = imgd2.data
  for ( i = 0, pixlen = pix.length; i < pixlen; i += 4 ) {
    if (pix[i+3] > 250) {
      lasti = i
      total++
    }
  }

  if (options.monitoring) {
    downloadImageData(imgd2, modality+" - "+safeguard)
  }

  while (total>0 && safeguard-->0) {
    total = 0

    // Reduce the cluster(s)
    // 1. blur
    for ( i=0; i<2; i++) {
      imgd2 = convolute(imgd2,
      [  0, .2,  0,
        .2, .2, .2,
         0, .2,  0 ]
      )
    }

    // 2. threshold
    pix = imgd2.data
    for ( i = 0, pixlen = pix.length; i < pixlen; i += 4 ) {
      if (pix[i+3] > 250) {
        pix[i+3] = 255
        lasti = i
        total++
      } else {
        pix[i+3] = 0
      }
    }

    if (options.monitoring) {
      downloadImageData(imgd2, modality+" - "+safeguard)
    }
  }
  
  var x = (lasti/4)%w
  var y = (lasti/4 - x)/w
  
  return [x, y]
}

function normalizeAlpha(imgd, minalpha, maxalpha, dryWet, _ctx) {
	if (_ctx === undefined) { _ctx = ctx }
  var w = imgd.width
  var h = imgd.height
  var pix = imgd.data
  // output
  var imgdo = _ctx.createImageData(w,h)
  var pixo = imgdo.data

  var min = Infinity
  var max = 0
  for ( var i = 0, pixlen = pixo.length; i < pixlen; i += 4 ) {
    var a = pix[i+3]
    min = Math.min(a, min)
    max = Math.max(a, max)
  }
  for ( var i = 0, pixlen = pixo.length; i < pixlen; i += 4 ) {
    pixo[i+3] = Math.floor(dryWet * (minalpha + (maxalpha-minalpha)*(pix[i+3]-min)/(max-min)) + (1-dryWet)*pix[i+3])
  }

  return imgdo
}

function multiplyAlpha(imgd, alpha) {
  var w = imgd.width
  var h = imgd.height
  var pix = imgd.data
  // output
  var imgdo = ctx.createImageData(w,h)
  var pixo = imgdo.data

  for ( var i = 0, pixlen = pixo.length; i < pixlen; i += 4 ) {
    pixo[i+0] = pix[i+0]
    pixo[i+1] = pix[i+1]
    pixo[i+2] = pix[i+2]
    pixo[i+3] = Math.floor(alpha * pix[i+3])
  }

  return imgdo
}

function alphacontrast(imgd, minalpha, threshold, factor) {
  var w = imgd.width
  var h = imgd.height
  var threshold255 = threshold * 255
  var contrast = buildConstrastFunction(factor, threshold255, minalpha)
  var pix = imgd.data
  // output
  var imgdo = ctx.createImageData(w,h)
  var pixo = imgdo.data

  // Split channels
  var channels = [[], [], [], []] // rgba
  for ( var i = 0, pixlen = pixo.length; i < pixlen; i += 4 ) {
    // Just process the alpha channel
    pixo[i+3] = contrast(pix[i+3])
  }

  return imgdo
}

function buildConstrastFunction(factor, threshold255, minalpha) {
  var samin = 255 / (1 + Math.exp( -factor * (0 - threshold255) ))
  var samax = 255 / (1 + Math.exp( -factor * (1 - threshold255) ))
  var contrast = function(alpha) {
    var alpha2 = alpha / ( 1 - minalpha ) - 255 * minalpha // Alpha corrected to remove the minalpha
    var s_alpha = 255 / (1 + Math.exp( -factor * (alpha2 - threshold255) )) // Sigmoid contrast
    return (s_alpha - samin) / (samax - samin) // Correct the extent of the sigmoid function
  }
  return contrast
}

function blur(imgd, r, _ctx) {
	if (_ctx === undefined) { _ctx = ctx }
  var i
  var w = imgd.width
  var h = imgd.height
  var pix = imgd.data
  var pixlen = pix.length
  // output
  var imgdo = _ctx.createImageData(w,h)
  var pixo = imgdo.data

  // Split channels
  var channels = [] // rgba
  for ( i=0; i<4; i++) {
    var channel = new Uint8ClampedArray(pixlen/4);
    channels.push(channel)
  }
  for ( i = 0; i < pixlen; i += 4 ) {
    channels[0][i/4] = pix[i  ]
    channels[1][i/4] = pix[i+1]
    channels[2][i/4] = pix[i+2]
    channels[3][i/4] = pix[i+3]
  }

  channels.forEach(function(scl){
    var tcl = scl.slice(0)
    var bxs = boxesForGauss(r, 3);
    boxBlur (scl, tcl, w, h, (bxs[0]-1)/2);
    boxBlur (tcl, scl, w, h, (bxs[1]-1)/2);
    boxBlur (scl, tcl, w, h, (bxs[2]-1)/2);
    scl = tcl
  })

  // Merge channels
  for ( var i = 0, pixlen = pixo.length; i < pixlen; i += 4 ) {
    pixo[i  ] = channels[0][i/4]
    pixo[i+1] = channels[1][i/4]
    pixo[i+2] = channels[2][i/4]
    pixo[i+3] = channels[3][i/4]
  }

  return imgdo
}

// From http://blog.ivank.net/fastest-gaussian-blur.html
function boxesForGauss(sigma, n) { // standard deviation, number of boxes

  var wIdeal = Math.sqrt((12*sigma*sigma/n)+1);  // Ideal averaging filter width 
  var wl = Math.floor(wIdeal);  if(wl%2==0) wl--;
  var wu = wl+2;
  
  var mIdeal = (12*sigma*sigma - n*wl*wl - 4*n*wl - 3*n)/(-4*wl - 4);
  var m = Math.round(mIdeal);
  // var sigmaActual = Math.sqrt( (m*wl*wl + (n-m)*wu*wu - n)/12 );
      
  var sizes = [];  for(var i=0; i<n; i++) sizes.push(i<m?wl:wu);
  return sizes;
}

function boxBlur (scl, tcl, w, h, r) {
  for(var i=0; i<scl.length; i++) tcl[i] = scl[i];
  boxBlurH(tcl, scl, w, h, r);
  boxBlurT(scl, tcl, w, h, r);
}

function boxBlurH (scl, tcl, w, h, r) {
  var iarr = 1 / (r+r+1);
  for(var i=0; i<h; i++) {
    var ti = i*w, li = ti, ri = ti+r;
    var fv = scl[ti], lv = scl[ti+w-1], val = (r+1)*fv;
    for(var j=0; j<r; j++) val += scl[ti+j];
    for(var j=0  ; j<=r ; j++) { val += scl[ri++] - fv       ;   tcl[ti++] = Math.round(val*iarr); }
    for(var j=r+1; j<w-r; j++) { val += scl[ri++] - scl[li++];   tcl[ti++] = Math.round(val*iarr); }
    for(var j=w-r; j<w  ; j++) { val += lv        - scl[li++];   tcl[ti++] = Math.round(val*iarr); }
  }
}

function boxBlurT (scl, tcl, w, h, r) {
  var iarr = 1 / (r+r+1);
  for(var i=0; i<w; i++) {
    var ti = i, li = ti, ri = ti+r*w;
    var fv = scl[ti], lv = scl[ti+w*(h-1)], val = (r+1)*fv;
    for(var j=0; j<r; j++) val += scl[ti+j*w];
    for(var j=0  ; j<=r ; j++) { val += scl[ri] - fv     ;  tcl[ti] = Math.round(val*iarr);  ri+=w; ti+=w; }
    for(var j=r+1; j<h-r; j++) { val += scl[ri] - scl[li];  tcl[ti] = Math.round(val*iarr);  li+=w; ri+=w; ti+=w; }
    for(var j=h-r; j<h  ; j++) { val += lv      - scl[li];  tcl[ti] = Math.round(val*iarr);  li+=w; ti+=w; }
  }
}

function tuneColorForLabel(c) {
  var options = {}
  options.label_color_min_C = 0
  options.label_color_max_C = 50
  options.label_color_min_L = 2
  options.label_color_max_L = 35
  var hcl = d3.hcl(c)
  hcl.c = Math.max(hcl.c, options.label_color_min_C)
  hcl.c = Math.min(hcl.c, options.label_color_max_C)
  hcl.l = Math.max(hcl.l, options.label_color_min_L)
  hcl.l = Math.min(hcl.l, options.label_color_max_L)
  return d3.color(hcl)
}

function getBBox(ctx, fontSize, labelCoordinates, label, factor, offset) {
  var x = labelCoordinates.x
  var y = labelCoordinates.y - 0.8 * fontSize
  var w = ctx.measureText(label).width
  var h = fontSize
  var ymargin = (h * factor - h)/2 + offset
  // Note: we use y margin as x margin too
  // because labels are wider and we want to have
  // a homogeneous margin
  return {
    x: x - ymargin,
    y: y - ymargin,
    width: w + 2*ymargin,
    height: h + 2*ymargin
  }
}

function downloadImageData(imgd, name) {
  // New Canvas
  var newCanvas = createCanvas(imgd.width, imgd.height)
  var ctx = newCanvas.getContext("2d")

  // Paint imgd
  ctx.putImageData(imgd, 0, 0)

  // Save
  const out = fs.createWriteStream(__dirname + '/data/'+name+'.png')
	const stream = newCanvas.createPNGStream()
	stream.pipe(out)
  // newCanvas.toBlob(function(blob) {
  //   saveAs(blob, name + ".png");
  // })
}

function buildContextFontString(fontWeight, fontSize, fontFamily) {
	// Browser
	// return fontWeight + " " + fontSize + "px " + fontFamily
	// Node
	var weightSuffix
	fontWeight = +fontWeight
	switch (fontWeight) {
		case 100:
			weightSuffix = " Thin"
			break
		case 200:
			weightSuffix = " ExtraLight"
			break
		case 300:
			weightSuffix = " Light"
			break
		case 400:
			weightSuffix = ""
			break
		case 500:
			weightSuffix = " Medium"
			break
		case 600:
			weightSuffix = " SemiBold"
			break
		case 700:
			return "bold " + fontSize + "px " + fontFamily
			break
		case 800:
			weightSuffix = " ExtraBold"
			break
		case 900:
			weightSuffix = " Black"
			break
	}
	// Normalize font size
	fontSize = Math.floor(1000 * fontSize)/1000
	return fontSize + "px " + fontFamily + weightSuffix
}

function truncateWithEllipsis(string, n){
	if (n && n<Infinity)	return string.substr(0,n-1)+(string.length>n?'…':'');
	return string
}

//// LOG
var logTime
function log(txt) {
  console.log(txt)
  logTime = Date.now()
}
function report(txt) {
  if (logTime) {
    var time = Date.now() - logTime
    time /= 1000
    txt += " TIME: "+time+" s"
  }
  console.log(txt)
  logTime = Date.now()
}